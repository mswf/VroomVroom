#include "shader.h"
#include "../Utilities/opengl_common.h"
#include "../Utilities/helperFunctions.h"
#include "content.h"
#include "console.h"

//TODO(VALENTINAS): Keep track of loaded shader programs, detach & link when reloading,
// GL_INVALID_FRAMEBUFFER_OPERATION Given when doing anything that would attempt to read from or write/render to a framebuffer that is not complete.
/*
// UniformBlock
// 		Active uniform block
//		Get uniform block location
//
// 		create material uniform buffer
//			glGenBuffers(1,&(aMesh.uniformBlockIndex));
//			glBindBuffer(GL_UNIFORM_BUFFER,aMesh.uniformBlockIndex);
//			glBufferData(GL_UNIFORM_BUFFER, sizeof(aMat), (void *)(&aMat), GL_STATIC_DRAW);
//
//	OTHER:
//
// 	glBindAttribLocation
//	glBindFragDataLocation(program, 0, "outColor");
*/

Shader::Shader() :
	program(0)
{
	std::string vs, fs;
	std::string defaultVertex = Content::GetPath() + std::string("/shaders/default.vert");
	std::string defaultFragment = Content::GetPath() + std::string("/shaders/default.frag");
	bool vExists = HelperFunctions::FileExists( defaultVertex.c_str() );
	bool fExists = HelperFunctions::FileExists( defaultFragment.c_str() );
	
	if ( vExists && fExists )
	{
		vs = HelperFunctions::ReadFile( defaultVertex.c_str() );
		fs = HelperFunctions::ReadFile( defaultFragment.c_str() );
	}
	else
	{
		vs = builtin_vertex;
		fs = builtin_fragment;
	}

	ShaderObject vertex_shader_object, fragment_shader_object;
	vertex_shader_object.shader = CreateShader( GLSLShaderType::VERTEX, vs.c_str() );
	vertex_shader_object.shaderType = GL_VERTEX_SHADER;
	fragment_shader_object.shader = CreateShader( GLSLShaderType::FRAGMENT, fs.c_str() );
	fragment_shader_object.shaderType = GL_FRAGMENT_SHADER;
	
	program = CreateProgram(vertex_shader_object.shader, fragment_shader_object.shader);
	
	//LogActiveSubroutines(program, GL_FRAGMENT_SHADER);
	
	SetSubroutineUniformLocations( program, fragment_shader_object );
	SetActiveSubroutine( program, fragment_shader_object, "shadeModel", "phongModel");
	
	/*
	GLuint programV = CreateSeparateProgram(vertex_shader_object);
	GLuint programF = CreateSeparateProgram(fragment_shader_object);
	
	GLuint ppo;
	glGenProgramPipelines(1, &ppo);
	glBindProgramPipeline(ppo);
	
	UseProgramStages( ppo, GLSLShaderType::VERTEX, programV );
	UseProgramStages( ppo, GLSLShaderType::FRAGMENT, programF );
	*/
	
	DeleteShaderObject( vertex_shader_object.shader );
	DeleteShaderObject( fragment_shader_object.shader );
}

Shader::Shader( std::string vs, std::string fs ) : program(0)
{
	vs = HelperFunctions::ReadFile( (Content::GetPath() + vs).c_str() );
	fs = HelperFunctions::ReadFile( (Content::GetPath() + fs).c_str() );
	GLuint vertex_shader_object = CreateShader( GLSLShaderType::VERTEX, vs.c_str() );
	GLuint fragment_shader_object = CreateShader( GLSLShaderType::FRAGMENT, fs.c_str() );
	program = CreateProgram(vertex_shader_object, fragment_shader_object);
}

Shader::~Shader()
{
	DeleteProgram( program );
	//if (subroutines != NULL)
	{
	//	free(subroutines);
	}
}

void Shader::DeleteShaderObject( GLuint shader )
{
	glDeleteShader(shader);
	//GL_INVALID_VALUE is generated if shader is not a value generated by OpenGL.
	CheckGlError( "glDeleteShader" );
}

void Shader::AttachShader( GLuint program, GLuint shader )
{
	glAttachShader( program, shader );
	// GL_INVALID_VALUE is generated if either program or shader is not a value generated by OpenGL.
	// GL_INVALID_OPERATION is generated if program is not a program object.
	// GL_INVALID_OPERATION is generated if shader is not a shader object.
	// GL_INVALID_OPERATION is generated if shader is already attached to program.
	CheckGlError( "glAttachShader" );
}

void Shader::DetachShader( GLuint program, GLuint shader )
{
	glDetachShader( program, shader );
	//GL_INVALID_VALUE is generated if either program or shader is a value that was not generated by OpenGL.
	//GL_INVALID_OPERATION is generated if program is not a program object.
	//GL_INVALID_OPERATION is generated if shader is not a shader object.
	//GL_INVALID_OPERATION is generated if shader is not attached to program.
	CheckGlError( "glDetachShader" );
}

void Shader::DeleteProgram( GLuint program )
{
	glDeleteProgram(program);
}

void Shader::LinkProgram( GLuint program )
{
	glLinkProgram( program );
	// GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
	// GL_INVALID_OPERATION is generated if program is not a program object.
	// GL_INVALID_OPERATION is generated if program is the currently active program object and transform feedback mode is active.
	CheckGlError( "glLinkProgram" );
}

GLuint Shader::CreateShader( GLSLShaderType shaderType, const char* source )
{
	GLuint shaderObject = glCreateShader( GetGLShaderEnum( shaderType ) );
	
	// GL_INVALID_ENUM is generated if shaderType is not an accepted value.
	CheckGlError( "glCreateShader" );
	
	// uint shader, sizei count, const char** string shader_source, const int lenght
	glShaderSource( shaderObject, 1, &source, NULL );
	
	// GL_INVALID_VALUE is generated if shader is not a value generated by OpenGL.
	// GL_INVALID_OPERATION is generated if shader is not a shader object.
	// GL_INVALID_VALUE is generated if count is less than 0.
	CheckGlError( "glShaderSource" );
	
	glCompileShader( shaderObject );
	if ( !ShaderInfoLog( shaderObject, GL_COMPILE_STATUS ) )
	{
		return 0;
	}
	return shaderObject;
}

bool Shader::ShaderInfoLog( GLuint program, GLenum status )
{
	GLint log;
	glGetShaderiv( program, status, &log);
	if (log == GL_FALSE)
	{
		GLchar message[255];
		glGetShaderInfoLog( program, sizeof(message), 0, &message[0]);
		Terminal.LogOpenGL( "ShaderLog: " + std::string( message ), true );
		return false;
	}
	return true;
}

template<typename... Targs>
GLuint Shader::CreateProgram( Targs... shaderObjects )
{
	int i;
	const int size = sizeof...( shaderObjects );
	GLuint shaders[ size ] = { shaderObjects... };
	GLuint shaderProgram = glCreateProgram();
	if ( shaderProgram == 0 )
	{
		Terminal.LogOpenGL( "glCreateProgram failed to create a program object." );
		return 0;
	}
	for (i = 0; i < size; ++i)
	{
		AttachShader( shaderProgram, shaders[i] );
	}
	LinkProgram( shaderProgram );
	ProgramInfoLog( shaderProgram, GL_LINK_STATUS );
	return shaderProgram;
}

GLuint Shader::CreateSeparateProgram( GLenum shaderObject )
{
	GLuint shaderProgram = glCreateProgram();
	AttachShader( shaderProgram, shaderObject );
	glProgramParameteri( shaderProgram, GL_PROGRAM_SEPARABLE, GL_TRUE );
	LinkProgram( shaderProgram );
	ProgramInfoLog( shaderProgram, GL_LINK_STATUS );
	return shaderProgram;
}


bool Shader::ProgramInfoLog( GLuint program, GLenum status )
{
	GLint log;
	glGetProgramiv( program, status, &log);
	if (log == GL_FALSE)
	{
		GLchar message[255];
		glGetProgramInfoLog( program, sizeof(message), 0, &message[0]);
		Terminal.LogOpenGL( "ProgramLog: " + std::string( message ), true );
		return false;
	}
	return true;
}

void Shader::UseProgram()
{
	glUseProgram( program );
	// GL_INVALID_VALUE is generated if program is neither 0 nor a value generated by OpenGL.
	// GL_INVALID_OPERATION is generated if program is not a program object.
	// GL_INVALID_OPERATION is generated if program could not be made part of current state.
	// GL_INVALID_OPERATION is generated if transform feedback mode is active.
	CheckGlError( "glUseProgram" );
}

void Shader::UseProgramStages( GLuint pPipeline, GLSLShaderType shaderType, GLuint program )
{
	glUseProgramStages( pPipeline, GetGLShaderEnum(shaderType), program );
	CheckGlError( "UseProgramStages" );
}

bool Shader::IsShader( GLuint shader )
{
	return glIsShader( shader );
}

bool Shader::IsProgram( GLuint program )
{
	return glIsProgram( program );
}

bool Shader::ValidateProgram( GLuint shaderProgram )
{
	glValidateProgram( shaderProgram );
	return ProgramInfoLog( shaderProgram, GL_VALIDATE_STATUS );
}

void Shader::LogActiveAttributes( GLuint shaderProgram )
{
	GLint num_properties, size;
	int i;
	GLchar property_name[256];
	GLsizei length;
	GLenum type;
	
	glGetProgramiv( shaderProgram, GL_ACTIVE_ATTRIBUTES, &num_properties);
	
	for ( i = 0; i < num_properties; ++i )
	{
		glGetActiveUniform(shaderProgram, i, sizeof(property_name), &length, &size, &type, property_name);
		Terminal.LogOpenGL( std::string( "Attribute " + std::to_string(i) + ": " + property_name ) );
	}
}

void Shader::LogActiveUniforms( GLuint shaderProgram )
{
	GLint num_properties, size;
	int i;
	GLchar property_name[256];
	GLsizei length;
	GLenum type;

	glGetProgramiv( shaderProgram, GL_ACTIVE_UNIFORMS, &num_properties);
	
	for ( i = 0; i < num_properties; ++i )
	{
		glGetActiveUniform(shaderProgram, i, sizeof(property_name), &length, &size, &type, property_name);
		Terminal.LogOpenGL( std::string( "Uniform " + std::to_string(i) + ": " + property_name ) );
	}
}

void Shader::LogActiveSubroutines( GLuint shaderProgram, GLenum shaderType )
{
	int i, j, length, numCompatibleSubroutines, maxSubroutines, maxSubroutineUniforms, activeSubroutines, numActiveSubroutineUniforms;
	char name[256];
 
	glGetIntegerv( GL_MAX_SUBROUTINES, &maxSubroutines );
	glGetIntegerv( GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS, &maxSubroutineUniforms );
	std::string subroutineInfo( "Max Subroutines: " + std::to_string( maxSubroutines ) + "  Max Subroutine Uniforms: " + std::to_string( maxSubroutineUniforms ) );
	Terminal.LogOpenGL( subroutineInfo );
 
	glGetProgramStageiv( shaderProgram, shaderType, GL_ACTIVE_SUBROUTINES, &activeSubroutines );
	glGetProgramStageiv( shaderProgram, shaderType, GL_ACTIVE_SUBROUTINE_UNIFORMS, &numActiveSubroutineUniforms );
	Terminal.LogOpenGL( std::string( "Active Subroutines: " + std::to_string( activeSubroutines ) ) );
	Terminal.LogOpenGL( std::string( "Active Subroutine Uniforms: " + std::to_string( numActiveSubroutineUniforms ) ) );
	
	for ( i = 0; i < numActiveSubroutineUniforms; ++i )
	{
		glGetActiveSubroutineUniformName(shaderProgram, shaderType, i, 256, &length, name );
		
		Terminal.LogOpenGL( std::string( "Subroutine Uniform: " + std::to_string(i) + " name: " + name ) );
		glGetActiveSubroutineUniformiv( shaderProgram, shaderType, i, GL_NUM_COMPATIBLE_SUBROUTINES, &numCompatibleSubroutines );
		
		int *s = (int*)malloc( sizeof(int) * numCompatibleSubroutines );
		glGetActiveSubroutineUniformiv(shaderProgram, shaderType, i, GL_COMPATIBLE_SUBROUTINES, s);
		Terminal.LogOpenGL( "Compatible Subroutines:" );
		for ( j=0; j < numCompatibleSubroutines; ++j )
		{
			glGetActiveSubroutineName(shaderProgram, shaderType, s[j], 256, &length, name);
			Terminal.LogOpenGL( "\t" + std::to_string( s[j] ) + " - " + name );
		}
		Terminal.LogOpenGL( "---------" );
		free(s);
	}

}

GLenum Shader::GetGLShaderEnum( GLSLShaderType type, bool separate )
{
	GLenum shader = 0;
	switch (type)
	{
		case GLSLShaderType::VERTEX:
		{
			shader =  separate ? GL_VERTEX_SHADER_BIT : GL_VERTEX_SHADER;
			break;
		}
		case GLSLShaderType::GEOMETRY:
		{
			shader = separate ? GL_GEOMETRY_SHADER_BIT : GL_GEOMETRY_SHADER;
			break;
		}
		case GLSLShaderType::FRAGMENT:
		{
			shader = separate ? GL_FRAGMENT_SHADER_BIT : GL_FRAGMENT_SHADER;
			break;
		}
		case GLSLShaderType::TESS_CONTROL:
		{
			shader = separate ? GL_TESS_CONTROL_SHADER_BIT : GL_TESS_CONTROL_SHADER;
			break;
		}
		case GLSLShaderType::TESS_EVALUATION:
		{
			shader = separate ? GL_TESS_EVALUATION_SHADER_BIT : GL_TESS_EVALUATION_SHADER;
			break;
		}
		default:
		{
			shader = 0;
			break;
		}
	}
	return shader;
}

// UNIFORM SETTING

// SINGLE VALUE ( float, int, uint, double )
void Shader::SetUniform( const char* name, float val )
{
	glUniform1f( glGetUniformLocation( program, name ), val );
}
void Shader::SetUniform( const char* name, int val )
{
	glUniform1i( glGetUniformLocation ( program, name ), val );
}
void Shader::SetUniform( const char* name, unsigned int val )
{
	glUniform1ui( glGetUniformLocation ( program, name ), val );
}
void Shader::SetUniform( const char* name, double val )
{
	glUniform1d( glGetUniformLocation( program, name ), val );
}

// TUPLE VALUES ( float, int, uint )
void Shader::SetUniform(const char* name, const glm::vec2& vec )
{
	glUniform2f( glGetUniformLocation( program, name ), vec.x, vec.y );
}
void Shader::SetUniform(const char* name, const glm::ivec2& vec )
{
	glUniform2i( glGetUniformLocation( program, name ), vec.x, vec.y );
}
void Shader::SetUniform(const char* name, const glm::uvec2& vec )
{
	glUniform2ui( glGetUniformLocation( program, name ), vec.x, vec.y );
}

// TRIPLE VALUES ( float, int, uint )
void Shader::SetUniform(const char* name, const glm::vec3& vec )
{
	glUniform3f( glGetUniformLocation( program, name ), vec.x, vec.y, vec.z );
}
void Shader::SetUniform(const char* name, const glm::ivec3& vec )
{
	glUniform3i( glGetUniformLocation( program, name ), vec.x, vec.y, vec.z );
}
void Shader::SetUniform(const char* name, const glm::uvec3& vec )
{
	glUniform3ui( glGetUniformLocation( program, name ), vec.x, vec.y, vec.z );
}

// QUATER VALUES ( float, int, uint )
void Shader::SetUniform(const char* name, const glm::vec4& vec )
{
	glUniform4f( glGetUniformLocation( program, name ), vec.x, vec.y, vec.z, vec.w );
}
void Shader::SetUniform(const char* name, const glm::ivec4& vec )
{
	glUniform4i( glGetUniformLocation( program, name ), vec.x, vec.y, vec.z, vec.w );
}
void Shader::SetUniform(const char* name, const glm::uvec4& vec )
{
	glUniform4ui( glGetUniformLocation( program, name ), vec.x, vec.y, vec.z, vec.w );
}

// MATRICES ( 2x2f, 3x3f, 4x4f )
void Shader::SetUniform( const char* name, const glm::mat2& mat )
{
	glUniformMatrix2fv( glGetUniformLocation( program, name ), 1, GL_FALSE, glm::value_ptr(mat) );
}
void Shader::SetUniform( const char* name, const glm::mat3& mat )
{
	glUniformMatrix3fv( glGetUniformLocation( program, name ), 1, GL_FALSE, glm::value_ptr(mat) );
}
void Shader::SetUniform( const char* name, const glm::mat4& mat )
{
	glUniformMatrix4fv( glGetUniformLocation( program, name ), 1, GL_FALSE, glm::value_ptr(mat) );
}

// SUBROUTINES

void Shader::SetSubroutineUniformLocations( GLuint program, ShaderObject& shader )
{
	//TODO(Valentinas): Make a proper initialization for shader.subroutines
	int numActiveSubroutineUniforms;
	glGetProgramStageiv( program, shader.shaderType, GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS, &numActiveSubroutineUniforms );
	if (numActiveSubroutineUniforms > 0)
	{
		shader.numSubroutines = numActiveSubroutineUniforms;
		//TODO(Valentinas): USE NEW INSTEAD OF MALLOC?
		shader.subroutines = (GLuint*)malloc( sizeof(GLuint) * numActiveSubroutineUniforms );
		for ( int i = 0; i < numActiveSubroutineUniforms; ++i )
		{
			int length;
			char name[256];
			// Get subroutine uniform name
			glGetActiveSubroutineUniformName(program, shader.shaderType, i, 256, &length, name );
			//printf( "%s uniform.\n", name );
			shader.locations.insert( std::pair<std::string, unsigned int>( name, i ) );
			shader.subroutines[i] = 0;
		}
	}
}

unsigned int Shader::GetSubroutineUniformLocation( const char* name, const std::map< std::string, unsigned int >& locations )
{
	//TODO(Valentinas): ADD CHECK TO FIND WHETHER LOCATIONS EXISTS
	std::string value(name);
	return locations.at(value);
	//Terminal.LogOpenGL("Subroutine uniform not found.");
}

void Shader::SetActiveSubroutine( GLuint program, ShaderObject shader, const char* uniform, const char* routine )
{
	GLuint index = GetSubroutineUniformLocation( uniform, shader.locations );
	shader.subroutines[index] = glGetSubroutineIndex( program, shader.shaderType, routine );
	glUniformSubroutinesuiv( shader.shaderType, shader.numSubroutines, shader.subroutines );
	
	// GL_INVALID_OPERATION is generated if no program object is current.
	// GL_INVALID_VALUE is generated if count is not equal to the value of GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS for the shader stage shadertype of the current program.
	// GL_INVALID_VALUE is generated if any value in indices is greater than or equal to the value of GL_ACTIVE_SUBROUTINES for the shader stage shadertype of the current program.
	// GL_INVALID_ENUM is generated if shadertype is not one of the accepted values.
	CheckGlError("Subroutine");
	
	/*
	 for (int i =0; i<2; ++i)
	 {
		int in = shader.subroutines[i];
		printf("Subroutine: %i -> %i \n", i, in);
	 }
	 */
}
